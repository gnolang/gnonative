// @generated by protoc-gen-es v2.2.5 with parameter "target=ts"
// @generated from file rpc.proto (package land.gno.gnonative.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { ActivateAccountRequestSchema, ActivateAccountResponseSchema, AddressFromBech32RequestSchema, AddressFromBech32ResponseSchema, AddressFromMnemonicRequestSchema, AddressFromMnemonicResponseSchema, AddressToBech32RequestSchema, AddressToBech32ResponseSchema, BroadcastTxCommitRequestSchema, BroadcastTxCommitResponseSchema, CallRequestSchema, CallResponseSchema, CreateAccountRequestSchema, CreateAccountResponseSchema, DeleteAccountRequestSchema, DeleteAccountResponseSchema, EstimateGasRequestSchema, EstimateGasResponseSchema, GenerateRecoveryPhraseRequestSchema, GenerateRecoveryPhraseResponseSchema, GetActivatedAccountRequestSchema, GetActivatedAccountResponseSchema, GetChainIDRequestSchema, GetChainIDResponseSchema, GetKeyInfoByAddressRequestSchema, GetKeyInfoByAddressResponseSchema, GetKeyInfoByNameOrAddressRequestSchema, GetKeyInfoByNameOrAddressResponseSchema, GetKeyInfoByNameRequestSchema, GetKeyInfoByNameResponseSchema, GetRemoteRequestSchema, GetRemoteResponseSchema, HasKeyByAddressRequestSchema, HasKeyByAddressResponseSchema, HasKeyByNameOrAddressRequestSchema, HasKeyByNameOrAddressResponseSchema, HasKeyByNameRequestSchema, HasKeyByNameResponseSchema, HelloRequestSchema, HelloResponseSchema, HelloStreamRequestSchema, HelloStreamResponseSchema, ListKeyInfoRequestSchema, ListKeyInfoResponseSchema, MakeTxResponseSchema, QEvalRequestSchema, QEvalResponseSchema, QueryAccountRequestSchema, QueryAccountResponseSchema, QueryRequestSchema, QueryResponseSchema, RenderRequestSchema, RenderResponseSchema, RotatePasswordRequestSchema, RotatePasswordResponseSchema, RunRequestSchema, RunResponseSchema, SendRequestSchema, SendResponseSchema, SetChainIDRequestSchema, SetChainIDResponseSchema, SetPasswordRequestSchema, SetPasswordResponseSchema, SetRemoteRequestSchema, SetRemoteResponseSchema, SignTxRequestSchema, SignTxResponseSchema, ValidateMnemonicPhraseRequestSchema, ValidateMnemonicPhraseResponseSchema, ValidateMnemonicWordRequestSchema, ValidateMnemonicWordResponseSchema } from "./gnonativetypes_pb";
import { file_gnonativetypes } from "./gnonativetypes_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file rpc.proto.
 */
export const file_rpc: GenFile = /*@__PURE__*/
  fileDesc("CglycGMucHJvdG8SFWxhbmQuZ25vLmdub25hdGl2ZS52MSI7CgpFcnJEZXRhaWxzEi0KBWNvZGVzGAEgAygOMh4ubGFuZC5nbm8uZ25vbmF0aXZlLnYxLkVyckNvZGUqtAYKB0VyckNvZGUSDQoJVW5kZWZpbmVkEAASCAoEVE9ETxABEhUKEUVyck5vdEltcGxlbWVudGVkEAISDwoLRXJySW50ZXJuYWwQAxITCg9FcnJJbnZhbGlkSW5wdXQQZBIYChRFcnJCcmlkZ2VJbnRlcnJ1cHRlZBBlEhMKD0Vyck1pc3NpbmdJbnB1dBBmEhQKEEVyclNlcmlhbGl6YXRpb24QZxIWChJFcnJEZXNlcmlhbGl6YXRpb24QaBISCg5FcnJJbml0U2VydmljZRBpEhAKDEVyclNldFJlbW90ZRBqEhwKF0VyckNyeXB0b0tleVR5cGVVbmtub3duEJYBEhkKFEVyckNyeXB0b0tleU5vdEZvdW5kEJcBEhcKEkVyck5vQWN0aXZlQWNjb3VudBCYARIVChBFcnJSdW5HUlBDU2VydmVyEJkBEhgKE0VyckRlY3J5cHRpb25GYWlsZWQQmgESEAoLRXJyVHhEZWNvZGUQyAESFwoSRXJySW52YWxpZFNlcXVlbmNlEMkBEhQKD0VyclVuYXV0aG9yaXplZBDKARIZChRFcnJJbnN1ZmZpY2llbnRGdW5kcxDLARIWChFFcnJVbmtub3duUmVxdWVzdBDMARIWChFFcnJJbnZhbGlkQWRkcmVzcxDNARIWChFFcnJVbmtub3duQWRkcmVzcxDOARIVChBFcnJJbnZhbGlkUHViS2V5EM8BEhkKFEVyckluc3VmZmljaWVudENvaW5zENABEhQKD0VyckludmFsaWRDb2lucxDRARIYChNFcnJJbnZhbGlkR2FzV2FudGVkENIBEhAKC0Vyck91dE9mR2FzENMBEhQKD0Vyck1lbW9Ub29MYXJnZRDUARIXChJFcnJJbnN1ZmZpY2llbnRGZWUQ1QESGQoURXJyVG9vTWFueVNpZ25hdHVyZXMQ1gESFAoPRXJyTm9TaWduYXR1cmVzENcBEhMKDkVyckdhc092ZXJmbG93ENgBEhYKEUVyckludmFsaWRQa2dQYXRoENkBEhMKDkVyckludmFsaWRTdG10ENoBEhMKDkVyckludmFsaWRFeHByENsBMtIfChBHbm9OYXRpdmVTZXJ2aWNlEl4KCVNldFJlbW90ZRInLmxhbmQuZ25vLmdub25hdGl2ZS52MS5TZXRSZW1vdGVSZXF1ZXN0GigubGFuZC5nbm8uZ25vbmF0aXZlLnYxLlNldFJlbW90ZVJlc3BvbnNlEl4KCUdldFJlbW90ZRInLmxhbmQuZ25vLmdub25hdGl2ZS52MS5HZXRSZW1vdGVSZXF1ZXN0GigubGFuZC5nbm8uZ25vbmF0aXZlLnYxLkdldFJlbW90ZVJlc3BvbnNlEmEKClNldENoYWluSUQSKC5sYW5kLmduby5nbm9uYXRpdmUudjEuU2V0Q2hhaW5JRFJlcXVlc3QaKS5sYW5kLmduby5nbm9uYXRpdmUudjEuU2V0Q2hhaW5JRFJlc3BvbnNlEmEKCkdldENoYWluSUQSKC5sYW5kLmduby5nbm9uYXRpdmUudjEuR2V0Q2hhaW5JRFJlcXVlc3QaKS5sYW5kLmduby5nbm9uYXRpdmUudjEuR2V0Q2hhaW5JRFJlc3BvbnNlEoUBChZHZW5lcmF0ZVJlY292ZXJ5UGhyYXNlEjQubGFuZC5nbm8uZ25vbmF0aXZlLnYxLkdlbmVyYXRlUmVjb3ZlcnlQaHJhc2VSZXF1ZXN0GjUubGFuZC5nbm8uZ25vbmF0aXZlLnYxLkdlbmVyYXRlUmVjb3ZlcnlQaHJhc2VSZXNwb25zZRJkCgtMaXN0S2V5SW5mbxIpLmxhbmQuZ25vLmdub25hdGl2ZS52MS5MaXN0S2V5SW5mb1JlcXVlc3QaKi5sYW5kLmduby5nbm9uYXRpdmUudjEuTGlzdEtleUluZm9SZXNwb25zZRJnCgxIYXNLZXlCeU5hbWUSKi5sYW5kLmduby5nbm9uYXRpdmUudjEuSGFzS2V5QnlOYW1lUmVxdWVzdBorLmxhbmQuZ25vLmdub25hdGl2ZS52MS5IYXNLZXlCeU5hbWVSZXNwb25zZRJwCg9IYXNLZXlCeUFkZHJlc3MSLS5sYW5kLmduby5nbm9uYXRpdmUudjEuSGFzS2V5QnlBZGRyZXNzUmVxdWVzdBouLmxhbmQuZ25vLmdub25hdGl2ZS52MS5IYXNLZXlCeUFkZHJlc3NSZXNwb25zZRKCAQoVSGFzS2V5QnlOYW1lT3JBZGRyZXNzEjMubGFuZC5nbm8uZ25vbmF0aXZlLnYxLkhhc0tleUJ5TmFtZU9yQWRkcmVzc1JlcXVlc3QaNC5sYW5kLmduby5nbm9uYXRpdmUudjEuSGFzS2V5QnlOYW1lT3JBZGRyZXNzUmVzcG9uc2UScwoQR2V0S2V5SW5mb0J5TmFtZRIuLmxhbmQuZ25vLmdub25hdGl2ZS52MS5HZXRLZXlJbmZvQnlOYW1lUmVxdWVzdBovLmxhbmQuZ25vLmdub25hdGl2ZS52MS5HZXRLZXlJbmZvQnlOYW1lUmVzcG9uc2USfAoTR2V0S2V5SW5mb0J5QWRkcmVzcxIxLmxhbmQuZ25vLmdub25hdGl2ZS52MS5HZXRLZXlJbmZvQnlBZGRyZXNzUmVxdWVzdBoyLmxhbmQuZ25vLmdub25hdGl2ZS52MS5HZXRLZXlJbmZvQnlBZGRyZXNzUmVzcG9uc2USjgEKGUdldEtleUluZm9CeU5hbWVPckFkZHJlc3MSNy5sYW5kLmduby5nbm9uYXRpdmUudjEuR2V0S2V5SW5mb0J5TmFtZU9yQWRkcmVzc1JlcXVlc3QaOC5sYW5kLmduby5nbm9uYXRpdmUudjEuR2V0S2V5SW5mb0J5TmFtZU9yQWRkcmVzc1Jlc3BvbnNlEmoKDUNyZWF0ZUFjY291bnQSKy5sYW5kLmduby5nbm9uYXRpdmUudjEuQ3JlYXRlQWNjb3VudFJlcXVlc3QaLC5sYW5kLmduby5nbm9uYXRpdmUudjEuQ3JlYXRlQWNjb3VudFJlc3BvbnNlEnAKD0FjdGl2YXRlQWNjb3VudBItLmxhbmQuZ25vLmdub25hdGl2ZS52MS5BY3RpdmF0ZUFjY291bnRSZXF1ZXN0Gi4ubGFuZC5nbm8uZ25vbmF0aXZlLnYxLkFjdGl2YXRlQWNjb3VudFJlc3BvbnNlEmQKC1NldFBhc3N3b3JkEikubGFuZC5nbm8uZ25vbmF0aXZlLnYxLlNldFBhc3N3b3JkUmVxdWVzdBoqLmxhbmQuZ25vLmdub25hdGl2ZS52MS5TZXRQYXNzd29yZFJlc3BvbnNlEm0KDlJvdGF0ZVBhc3N3b3JkEiwubGFuZC5nbm8uZ25vbmF0aXZlLnYxLlJvdGF0ZVBhc3N3b3JkUmVxdWVzdBotLmxhbmQuZ25vLmdub25hdGl2ZS52MS5Sb3RhdGVQYXNzd29yZFJlc3BvbnNlEnwKE0dldEFjdGl2YXRlZEFjY291bnQSMS5sYW5kLmduby5nbm9uYXRpdmUudjEuR2V0QWN0aXZhdGVkQWNjb3VudFJlcXVlc3QaMi5sYW5kLmduby5nbm9uYXRpdmUudjEuR2V0QWN0aXZhdGVkQWNjb3VudFJlc3BvbnNlEmcKDFF1ZXJ5QWNjb3VudBIqLmxhbmQuZ25vLmdub25hdGl2ZS52MS5RdWVyeUFjY291bnRSZXF1ZXN0GisubGFuZC5nbm8uZ25vbmF0aXZlLnYxLlF1ZXJ5QWNjb3VudFJlc3BvbnNlEmoKDURlbGV0ZUFjY291bnQSKy5sYW5kLmduby5nbm9uYXRpdmUudjEuRGVsZXRlQWNjb3VudFJlcXVlc3QaLC5sYW5kLmduby5nbm9uYXRpdmUudjEuRGVsZXRlQWNjb3VudFJlc3BvbnNlElIKBVF1ZXJ5EiMubGFuZC5nbm8uZ25vbmF0aXZlLnYxLlF1ZXJ5UmVxdWVzdBokLmxhbmQuZ25vLmdub25hdGl2ZS52MS5RdWVyeVJlc3BvbnNlElUKBlJlbmRlchIkLmxhbmQuZ25vLmdub25hdGl2ZS52MS5SZW5kZXJSZXF1ZXN0GiUubGFuZC5nbm8uZ25vbmF0aXZlLnYxLlJlbmRlclJlc3BvbnNlElIKBVFFdmFsEiMubGFuZC5nbm8uZ25vbmF0aXZlLnYxLlFFdmFsUmVxdWVzdBokLmxhbmQuZ25vLmdub25hdGl2ZS52MS5RRXZhbFJlc3BvbnNlElEKBENhbGwSIi5sYW5kLmduby5nbm9uYXRpdmUudjEuQ2FsbFJlcXVlc3QaIy5sYW5kLmduby5nbm9uYXRpdmUudjEuQ2FsbFJlc3BvbnNlMAESUQoEU2VuZBIiLmxhbmQuZ25vLmdub25hdGl2ZS52MS5TZW5kUmVxdWVzdBojLmxhbmQuZ25vLmdub25hdGl2ZS52MS5TZW5kUmVzcG9uc2UwARJOCgNSdW4SIS5sYW5kLmduby5nbm9uYXRpdmUudjEuUnVuUmVxdWVzdBoiLmxhbmQuZ25vLmdub25hdGl2ZS52MS5SdW5SZXNwb25zZTABElcKCk1ha2VDYWxsVHgSIi5sYW5kLmduby5nbm9uYXRpdmUudjEuQ2FsbFJlcXVlc3QaJS5sYW5kLmduby5nbm9uYXRpdmUudjEuTWFrZVR4UmVzcG9uc2USVwoKTWFrZVNlbmRUeBIiLmxhbmQuZ25vLmdub25hdGl2ZS52MS5TZW5kUmVxdWVzdBolLmxhbmQuZ25vLmdub25hdGl2ZS52MS5NYWtlVHhSZXNwb25zZRJVCglNYWtlUnVuVHgSIS5sYW5kLmduby5nbm9uYXRpdmUudjEuUnVuUmVxdWVzdBolLmxhbmQuZ25vLmdub25hdGl2ZS52MS5NYWtlVHhSZXNwb25zZRJkCgtFc3RpbWF0ZUdhcxIpLmxhbmQuZ25vLmdub25hdGl2ZS52MS5Fc3RpbWF0ZUdhc1JlcXVlc3QaKi5sYW5kLmduby5nbm9uYXRpdmUudjEuRXN0aW1hdGVHYXNSZXNwb25zZRJVCgZTaWduVHgSJC5sYW5kLmduby5nbm9uYXRpdmUudjEuU2lnblR4UmVxdWVzdBolLmxhbmQuZ25vLmdub25hdGl2ZS52MS5TaWduVHhSZXNwb25zZRJ4ChFCcm9hZGNhc3RUeENvbW1pdBIvLmxhbmQuZ25vLmdub25hdGl2ZS52MS5Ccm9hZGNhc3RUeENvbW1pdFJlcXVlc3QaMC5sYW5kLmduby5nbm9uYXRpdmUudjEuQnJvYWRjYXN0VHhDb21taXRSZXNwb25zZTABEnAKD0FkZHJlc3NUb0JlY2gzMhItLmxhbmQuZ25vLmdub25hdGl2ZS52MS5BZGRyZXNzVG9CZWNoMzJSZXF1ZXN0Gi4ubGFuZC5nbm8uZ25vbmF0aXZlLnYxLkFkZHJlc3NUb0JlY2gzMlJlc3BvbnNlEnYKEUFkZHJlc3NGcm9tQmVjaDMyEi8ubGFuZC5nbm8uZ25vbmF0aXZlLnYxLkFkZHJlc3NGcm9tQmVjaDMyUmVxdWVzdBowLmxhbmQuZ25vLmdub25hdGl2ZS52MS5BZGRyZXNzRnJvbUJlY2gzMlJlc3BvbnNlEnwKE0FkZHJlc3NGcm9tTW5lbW9uaWMSMS5sYW5kLmduby5nbm9uYXRpdmUudjEuQWRkcmVzc0Zyb21NbmVtb25pY1JlcXVlc3QaMi5sYW5kLmduby5nbm9uYXRpdmUudjEuQWRkcmVzc0Zyb21NbmVtb25pY1Jlc3BvbnNlEn8KFFZhbGlkYXRlTW5lbW9uaWNXb3JkEjIubGFuZC5nbm8uZ25vbmF0aXZlLnYxLlZhbGlkYXRlTW5lbW9uaWNXb3JkUmVxdWVzdBozLmxhbmQuZ25vLmdub25hdGl2ZS52MS5WYWxpZGF0ZU1uZW1vbmljV29yZFJlc3BvbnNlEoUBChZWYWxpZGF0ZU1uZW1vbmljUGhyYXNlEjQubGFuZC5nbm8uZ25vbmF0aXZlLnYxLlZhbGlkYXRlTW5lbW9uaWNQaHJhc2VSZXF1ZXN0GjUubGFuZC5nbm8uZ25vbmF0aXZlLnYxLlZhbGlkYXRlTW5lbW9uaWNQaHJhc2VSZXNwb25zZRJSCgVIZWxsbxIjLmxhbmQuZ25vLmdub25hdGl2ZS52MS5IZWxsb1JlcXVlc3QaJC5sYW5kLmduby5nbm9uYXRpdmUudjEuSGVsbG9SZXNwb25zZRJmCgtIZWxsb1N0cmVhbRIpLmxhbmQuZ25vLmdub25hdGl2ZS52MS5IZWxsb1N0cmVhbVJlcXVlc3QaKi5sYW5kLmduby5nbm9uYXRpdmUudjEuSGVsbG9TdHJlYW1SZXNwb25zZTABQi9aJ2dpdGh1Yi5jb20vZ25vbGFuZy9nbm9uYXRpdmUvYXBpL2dlbi9nb6ICA1JUR2IGcHJvdG8z", [file_gnonativetypes]);

/**
 * @generated from message land.gno.gnonative.v1.ErrDetails
 */
export type ErrDetails = Message<"land.gno.gnonative.v1.ErrDetails"> & {
  /**
   * @generated from field: repeated land.gno.gnonative.v1.ErrCode codes = 1;
   */
  codes: ErrCode[];
};

/**
 * Describes the message land.gno.gnonative.v1.ErrDetails.
 * Use `create(ErrDetailsSchema)` to create a new message.
 */
export const ErrDetailsSchema: GenMessage<ErrDetails> = /*@__PURE__*/
  messageDesc(file_rpc, 0);

/**
 * The ErrCode enum defines errors for gRPC API functions. These are converted
 * from the Go error types returned by gnoclient.
 *
 * ----------------
 * Special errors
 * ----------------
 *
 * @generated from enum land.gno.gnonative.v1.ErrCode
 */
export enum ErrCode {
  /**
   * Undefined is the default value. It should never be set manually
   *
   * @generated from enum value: Undefined = 0;
   */
  Undefined = 0,

  /**
   * TODO indicates that you plan to create an error later
   *
   * @generated from enum value: TODO = 1;
   */
  TODO = 1,

  /**
   * ErrNotImplemented indicates that a method is not implemented yet
   *
   * @generated from enum value: ErrNotImplemented = 2;
   */
  ErrNotImplemented = 2,

  /**
   * ErrInternal indicates an unknown error (without Code), i.e. in gRPC
   *
   * @generated from enum value: ErrInternal = 3;
   */
  ErrInternal = 3,

  /**
   * @generated from enum value: ErrInvalidInput = 100;
   */
  ErrInvalidInput = 100,

  /**
   * @generated from enum value: ErrBridgeInterrupted = 101;
   */
  ErrBridgeInterrupted = 101,

  /**
   * @generated from enum value: ErrMissingInput = 102;
   */
  ErrMissingInput = 102,

  /**
   * @generated from enum value: ErrSerialization = 103;
   */
  ErrSerialization = 103,

  /**
   * @generated from enum value: ErrDeserialization = 104;
   */
  ErrDeserialization = 104,

  /**
   * @generated from enum value: ErrInitService = 105;
   */
  ErrInitService = 105,

  /**
   * @generated from enum value: ErrSetRemote = 106;
   */
  ErrSetRemote = 106,

  /**
   * @generated from enum value: ErrCryptoKeyTypeUnknown = 150;
   */
  ErrCryptoKeyTypeUnknown = 150,

  /**
   * ErrCryptoKeyNotFound indicates that the doesn't exist in the keybase
   *
   * @generated from enum value: ErrCryptoKeyNotFound = 151;
   */
  ErrCryptoKeyNotFound = 151,

  /**
   * ErrNoActiveAccount indicates that no account with the given address has been activated with ActivateAccount
   *
   * @generated from enum value: ErrNoActiveAccount = 152;
   */
  ErrNoActiveAccount = 152,

  /**
   * @generated from enum value: ErrRunGRPCServer = 153;
   */
  ErrRunGRPCServer = 153,

  /**
   * ErrDecryptionFailed indicates a decryption failure including a wrong password
   *
   * @generated from enum value: ErrDecryptionFailed = 154;
   */
  ErrDecryptionFailed = 154,

  /**
   * @generated from enum value: ErrTxDecode = 200;
   */
  ErrTxDecode = 200,

  /**
   * @generated from enum value: ErrInvalidSequence = 201;
   */
  ErrInvalidSequence = 201,

  /**
   * @generated from enum value: ErrUnauthorized = 202;
   */
  ErrUnauthorized = 202,

  /**
   * ErrInsufficientFunds indicates that there are insufficient funds to pay for fees
   *
   * @generated from enum value: ErrInsufficientFunds = 203;
   */
  ErrInsufficientFunds = 203,

  /**
   * ErrUnknownRequest indicates that the path of a realm function call is unrecognized
   *
   * @generated from enum value: ErrUnknownRequest = 204;
   */
  ErrUnknownRequest = 204,

  /**
   * ErrInvalidAddress indicates that an account address is blank or the bech32 can't be decoded
   *
   * @generated from enum value: ErrInvalidAddress = 205;
   */
  ErrInvalidAddress = 205,

  /**
   * ErrUnknownAddress indicates that the address is unknown on the blockchain
   *
   * @generated from enum value: ErrUnknownAddress = 206;
   */
  ErrUnknownAddress = 206,

  /**
   * ErrInvalidPubKey indicates that the public key was not found or has an invalid algorithm or format
   *
   * @generated from enum value: ErrInvalidPubKey = 207;
   */
  ErrInvalidPubKey = 207,

  /**
   * ErrInsufficientCoins indicates that the transaction has insufficient account funds to send
   *
   * @generated from enum value: ErrInsufficientCoins = 208;
   */
  ErrInsufficientCoins = 208,

  /**
   * ErrInvalidCoins indicates that the transaction Coins are not sorted, or don't have a
   * positive amount, or the coin Denom contains upper case characters
   *
   * @generated from enum value: ErrInvalidCoins = 209;
   */
  ErrInvalidCoins = 209,

  /**
   * ErrInvalidGasWanted indicates that the transaction gas wanted is too large or otherwise invalid
   *
   * @generated from enum value: ErrInvalidGasWanted = 210;
   */
  ErrInvalidGasWanted = 210,

  /**
   * ErrOutOfGas indicates that the transaction doesn't have enough gas
   *
   * @generated from enum value: ErrOutOfGas = 211;
   */
  ErrOutOfGas = 211,

  /**
   * ErrMemoTooLarge indicates that the transaction memo is too large
   *
   * @generated from enum value: ErrMemoTooLarge = 212;
   */
  ErrMemoTooLarge = 212,

  /**
   * ErrInsufficientFee indicates that the gas fee is insufficient
   *
   * @generated from enum value: ErrInsufficientFee = 213;
   */
  ErrInsufficientFee = 213,

  /**
   * ErrTooManySignatures indicates that the transaction has too many signatures
   *
   * @generated from enum value: ErrTooManySignatures = 214;
   */
  ErrTooManySignatures = 214,

  /**
   * ErrNoSignatures indicates that the transaction has no signatures
   *
   * @generated from enum value: ErrNoSignatures = 215;
   */
  ErrNoSignatures = 215,

  /**
   * ErrGasOverflow indicates that an action results in a gas consumption unsigned integer overflow
   *
   * @generated from enum value: ErrGasOverflow = 216;
   */
  ErrGasOverflow = 216,

  /**
   * ErrInvalidPkgPath indicates that the package path is not recognized.
   *
   * @generated from enum value: ErrInvalidPkgPath = 217;
   */
  ErrInvalidPkgPath = 217,

  /**
   * @generated from enum value: ErrInvalidStmt = 218;
   */
  ErrInvalidStmt = 218,

  /**
   * @generated from enum value: ErrInvalidExpr = 219;
   */
  ErrInvalidExpr = 219,
}

/**
 * Describes the enum land.gno.gnonative.v1.ErrCode.
 */
export const ErrCodeSchema: GenEnum<ErrCode> = /*@__PURE__*/
  enumDesc(file_rpc, 0);

/**
 * GnoNativeService is the service to interact with the Gno blockchain
 *
 * @generated from service land.gno.gnonative.v1.GnoNativeService
 */
export const GnoNativeService: GenService<{
  /**
   * Set the connection address for the remote node. If you don't call this,
   * the default is "127.0.0.1:26657"
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.SetRemote
   */
  setRemote: {
    methodKind: "unary";
    input: typeof SetRemoteRequestSchema;
    output: typeof SetRemoteResponseSchema;
  },
  /**
   * Get the connection address for the remote node. The response is either
   * the initial default, or the value which was set with SetRemote
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.GetRemote
   */
  getRemote: {
    methodKind: "unary";
    input: typeof GetRemoteRequestSchema;
    output: typeof GetRemoteResponseSchema;
  },
  /**
   * Set the chain ID for the remote node. If you don't call this, the default
   * is "dev"
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.SetChainID
   */
  setChainID: {
    methodKind: "unary";
    input: typeof SetChainIDRequestSchema;
    output: typeof SetChainIDResponseSchema;
  },
  /**
   * Get the chain ID for the remote node. The response is either
   * the initial default, or the value which was set with SetChainID
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.GetChainID
   */
  getChainID: {
    methodKind: "unary";
    input: typeof GetChainIDRequestSchema;
    output: typeof GetChainIDResponseSchema;
  },
  /**
   * Generate a recovery phrase of BIP39 mnemonic words using entropy from the
   * crypto library random number generator. This can be used as the mnemonic in
   * CreateAccount.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.GenerateRecoveryPhrase
   */
  generateRecoveryPhrase: {
    methodKind: "unary";
    input: typeof GenerateRecoveryPhraseRequestSchema;
    output: typeof GenerateRecoveryPhraseResponseSchema;
  },
  /**
   * Get the information for all keys in the keybase
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.ListKeyInfo
   */
  listKeyInfo: {
    methodKind: "unary";
    input: typeof ListKeyInfoRequestSchema;
    output: typeof ListKeyInfoResponseSchema;
  },
  /**
   * Check for the key in the keybase with the given name.
   * In the response, set has true if the keybase has the key.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.HasKeyByName
   */
  hasKeyByName: {
    methodKind: "unary";
    input: typeof HasKeyByNameRequestSchema;
    output: typeof HasKeyByNameResponseSchema;
  },
  /**
   * Check for the key in the keybase with the given address.
   * In the response, set has true if the keybase has the key.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.HasKeyByAddress
   */
  hasKeyByAddress: {
    methodKind: "unary";
    input: typeof HasKeyByAddressRequestSchema;
    output: typeof HasKeyByAddressResponseSchema;
  },
  /**
   * Check for the key in the keybase with the given name or bech32 string address.
   * In the response, set has true if the keybase has the key.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.HasKeyByNameOrAddress
   */
  hasKeyByNameOrAddress: {
    methodKind: "unary";
    input: typeof HasKeyByNameOrAddressRequestSchema;
    output: typeof HasKeyByNameOrAddressResponseSchema;
  },
  /**
   * Get the information for the key in the keybase with the given name.
   * If the key doesn't exist, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrCryptoKeyNotFound.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.GetKeyInfoByName
   */
  getKeyInfoByName: {
    methodKind: "unary";
    input: typeof GetKeyInfoByNameRequestSchema;
    output: typeof GetKeyInfoByNameResponseSchema;
  },
  /**
   * Get the information for the key in the keybase with the given address.
   * If the key doesn't exist, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrCryptoKeyNotFound.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.GetKeyInfoByAddress
   */
  getKeyInfoByAddress: {
    methodKind: "unary";
    input: typeof GetKeyInfoByAddressRequestSchema;
    output: typeof GetKeyInfoByAddressResponseSchema;
  },
  /**
   * Get the information for the key in the keybase with the given name or bech32 string address.
   * If the key doesn't exist, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrCryptoKeyNotFound.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.GetKeyInfoByNameOrAddress
   */
  getKeyInfoByNameOrAddress: {
    methodKind: "unary";
    input: typeof GetKeyInfoByNameOrAddressRequestSchema;
    output: typeof GetKeyInfoByNameOrAddressResponseSchema;
  },
  /**
   * Create a new account in the keybase using the name and password specified by SetAccount.
   * If an account with the same name already exists in the keybase,
   * this replaces it. (If you don't want to replace it, then it's your responsibility
   * to use GetKeyInfoByName to check if it exists before calling this.)
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.CreateAccount
   */
  createAccount: {
    methodKind: "unary";
    input: typeof CreateAccountRequestSchema;
    output: typeof CreateAccountResponseSchema;
  },
  /**
   * Find the account in the keybase with the given name_or_bech32 and activate it. If the response has_password is
   * false, then you should call SetPassword before using a method which needs it.
   * If the account is already activated, return its info.
   * If the key doesn't exist, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrCryptoKeyNotFound.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.ActivateAccount
   */
  activateAccount: {
    methodKind: "unary";
    input: typeof ActivateAccountRequestSchema;
    output: typeof ActivateAccountResponseSchema;
  },
  /**
   * Set the password for the account in the keybase with the given address.
   * If there is no activated account with the given address, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrNoActiveAccount.
   * If the password is wrong, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrDecryptionFailed.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.SetPassword
   */
  setPassword: {
    methodKind: "unary";
    input: typeof SetPasswordRequestSchema;
    output: typeof SetPasswordResponseSchema;
  },
  /**
   * Rotate the password of a key to a new password for the accounts in the keybase with the given addresses.
   * Before calling this, you must call SetPassword with the current password for each account.
   * If there is an error, then roll back all accounts to the current password.
   * If there is no activated account with the given address, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrNoActiveAccount.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.RotatePassword
   */
  rotatePassword: {
    methodKind: "unary";
    input: typeof RotatePasswordRequestSchema;
    output: typeof RotatePasswordResponseSchema;
  },
  /**
   * GetActivatedAccount gets the info of the account by address which has been activated by ActivateAccount.
   * If there the given address is not specified, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrInvalidAddress.
   * If there is no activated account with the given address, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrNoActiveAccount.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.GetActivatedAccount
   */
  getActivatedAccount: {
    methodKind: "unary";
    input: typeof GetActivatedAccountRequestSchema;
    output: typeof GetActivatedAccountResponseSchema;
  },
  /**
   * QueryAccount retrieves account information from the blockchain for a given
   * address.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.QueryAccount
   */
  queryAccount: {
    methodKind: "unary";
    input: typeof QueryAccountRequestSchema;
    output: typeof QueryAccountResponseSchema;
  },
  /**
   * DeleteAccount deletes the account with the given name, using the password
   * to ensure access. However, if skip_password is true, then ignore the
   * password.
   * If the account doesn't exist, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrCryptoKeyNotFound.
   * If the password is wrong, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrDecryptionFailed.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.DeleteAccount
   */
  deleteAccount: {
    methodKind: "unary";
    input: typeof DeleteAccountRequestSchema;
    output: typeof DeleteAccountResponseSchema;
  },
  /**
   * Make an ABCI query to the remote node.
   * If the request path is unrecognized, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrUnknownRequest.
   * If the request data has a package path that is unrecognized, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrInvalidPkgPath.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.Query
   */
  query: {
    methodKind: "unary";
    input: typeof QueryRequestSchema;
    output: typeof QueryResponseSchema;
  },
  /**
   * Render calls the Render function for package_path with optional args. The
   * package path should include the prefix like "gno.land/". This is similar to
   * using a browser URL <nodeURL>/<pkgPath>:<args> where <pkgPath> doesn't have
   * the prefix like "gno.land/".
   * If the request package_path is unrecognized, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrInvalidPkgPath.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.Render
   */
  render: {
    methodKind: "unary";
    input: typeof RenderRequestSchema;
    output: typeof RenderResponseSchema;
  },
  /**
   * QEval evaluates the given expression with the realm code at package_path.
   * The package path should include the prefix like "gno.land/". The expression
   * is usually a function call like "GetBoardIDFromName(\"testboard\")". The
   * return value is a typed expression like
   * "(1 gno.land/r/demo/boards.BoardID)\n(true bool)".
   * If the request package_path is unrecognized, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrInvalidPkgPath.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.QEval
   */
  qEval: {
    methodKind: "unary";
    input: typeof QEvalRequestSchema;
    output: typeof QEvalResponseSchema;
  },
  /**
   * Call a specific realm function. Sign the transaction with the given caller_address.
   * If there is no activated account with the given caller_address, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrNoActiveAccount.
   * If the password is wrong, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrDecryptionFailed.
   * If the path of a realm function call is unrecognized, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrUnknownRequest.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.Call
   */
  call: {
    methodKind: "server_streaming";
    input: typeof CallRequestSchema;
    output: typeof CallResponseSchema;
  },
  /**
   * Send currency from the account with the given caller_address to an account on the blockchain.
   * If there is no activated account with the given caller_address, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrNoActiveAccount.
   * If the password is wrong, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrDecryptionFailed.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.Send
   */
  send: {
    methodKind: "server_streaming";
    input: typeof SendRequestSchema;
    output: typeof SendResponseSchema;
  },
  /**
   * Temporarily load the code in package on the blockchain and run main() which can
   * call realm functions and use println() to output to the "console". Sign the transaction with the given caller_address.
   * This returns the "console" output.
   * If there is no activated account with the given caller_address, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrNoActiveAccount.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.Run
   */
  run: {
    methodKind: "server_streaming";
    input: typeof RunRequestSchema;
    output: typeof RunResponseSchema;
  },
  /**
   * Make an unsigned transaction to call a specific realm function.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.MakeCallTx
   */
  makeCallTx: {
    methodKind: "unary";
    input: typeof CallRequestSchema;
    output: typeof MakeTxResponseSchema;
  },
  /**
   * Make an unsigned transaction to send currency to an account on the blockchain.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.MakeSendTx
   */
  makeSendTx: {
    methodKind: "unary";
    input: typeof SendRequestSchema;
    output: typeof MakeTxResponseSchema;
  },
  /**
   * Make an unsigned transaction to temporarily load the code in package on the blockchain and run main().
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.MakeRunTx
   */
  makeRunTx: {
    methodKind: "unary";
    input: typeof RunRequestSchema;
    output: typeof MakeTxResponseSchema;
  },
  /**
   * EstimateGas estimates the least amount of gas required for the transaction to go through on the chain (minimum gas wanted), with a security margin.
   * If UpdateTx is true, then update the transaction with the gasWanted amount.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.EstimateGas
   */
  estimateGas: {
    methodKind: "unary";
    input: typeof EstimateGasRequestSchema;
    output: typeof EstimateGasResponseSchema;
  },
  /**
   * Sign the transaction using the account with the given address.
   * If there is no activated account with the given address, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrNoActiveAccount.
   * If the password is wrong, return [ErrCode](#land.gno.gnonative.v1.ErrCode).ErrDecryptionFailed.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.SignTx
   */
  signTx: {
    methodKind: "unary";
    input: typeof SignTxRequestSchema;
    output: typeof SignTxResponseSchema;
  },
  /**
   * Broadcast the signed transaction to the blockchain configured in GetRemote and return a stream result.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.BroadcastTxCommit
   */
  broadcastTxCommit: {
    methodKind: "server_streaming";
    input: typeof BroadcastTxCommitRequestSchema;
    output: typeof BroadcastTxCommitResponseSchema;
  },
  /**
   * Convert a byte array address to a bech32 string address.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.AddressToBech32
   */
  addressToBech32: {
    methodKind: "unary";
    input: typeof AddressToBech32RequestSchema;
    output: typeof AddressToBech32ResponseSchema;
  },
  /**
   * Convert a bech32 string address to a byte array address.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.AddressFromBech32
   */
  addressFromBech32: {
    methodKind: "unary";
    input: typeof AddressFromBech32RequestSchema;
    output: typeof AddressFromBech32ResponseSchema;
  },
  /**
   * Convert a mnemonic (as in CreateAccount) to a byte array address.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.AddressFromMnemonic
   */
  addressFromMnemonic: {
    methodKind: "unary";
    input: typeof AddressFromMnemonicRequestSchema;
    output: typeof AddressFromMnemonicResponseSchema;
  },
  /**
   * Validate a single mnemonic word (for example, as in CreateAccount).
   * In the response, set valid true if the mnemonic word is valid.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.ValidateMnemonicWord
   */
  validateMnemonicWord: {
    methodKind: "unary";
    input: typeof ValidateMnemonicWordRequestSchema;
    output: typeof ValidateMnemonicWordResponseSchema;
  },
  /**
   * Validate a mnemonic phrase (for example, as in CreateAccount).
   * In the response, set valid true if the mnemonic phrase is valid.
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.ValidateMnemonicPhrase
   */
  validateMnemonicPhrase: {
    methodKind: "unary";
    input: typeof ValidateMnemonicPhraseRequestSchema;
    output: typeof ValidateMnemonicPhraseResponseSchema;
  },
  /**
   * Hello is for debug purposes
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.Hello
   */
  hello: {
    methodKind: "unary";
    input: typeof HelloRequestSchema;
    output: typeof HelloResponseSchema;
  },
  /**
   * HelloStream is for debug purposes
   *
   * @generated from rpc land.gno.gnonative.v1.GnoNativeService.HelloStream
   */
  helloStream: {
    methodKind: "server_streaming";
    input: typeof HelloStreamRequestSchema;
    output: typeof HelloStreamResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_rpc, 0);

